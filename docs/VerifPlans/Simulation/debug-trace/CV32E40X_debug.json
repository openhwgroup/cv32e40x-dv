[
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug cod\n\nEnsure exception routine is not enterred",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug cod\n\nEnsure exception routine is not enterred",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_with_ebreakm\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_with_ebreakm\nA  :uvmt_cv32_tb.u_debug_assert.a_cebreak_debug_mode",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1\n\n",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary exception code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Debug mode can be entered by executing the EBREAK or C.EBREAK instruction when dcsr.ebreakm = 1\ncause = 1\n\n",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary exception code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A: Hard to detect that we are executing an exception handler.\nCovered in debug_test with ISS enabled.",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_without_ebreakm (ebreak_regular_nodebug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_without_ebreakm (cebreak_regular_nodebug)\nA: uvmt_cv32_tb.u_debug_assert.a_ebreak_exception\nA: uvmt_cv32_tb.u_debug_assert.a.cebreak_exception",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception during single stepping",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary single stepping code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_known_miscompares\"",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213\n\nCV32E40P doc rev 46711ac",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Enter ebreak exception during single stepping",
        "Sub Feature": "EBREAK instruction",
        "Feature Description": "Enter ebreak exception routine when calling EBREAK or C.EBREAK when dcsr.ebreakm == 0.",
        "Verification Goal": "Add EBREAK or/and C.EBREAK to arbitrary single stepping code\nVerify that:\nCore switches into debug mode.\nPC of EBREAK instruction must be saved to DPC\nCause of debug must be saved to DCSR (cause=1)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code\nEnsure exception routine is not entered",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_execute_without_ebreakm (ebreak_step_nodebug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_execute_without_ebreakm (cebreak_step_nodebug)\nA: uvmt_cv32_tb.u_debug_assert.a_ebreak_exception\nA: uvmt_cv32_tb.u_debug_assert.a.cebreak_exception",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "External debug event",
        "Feature Description": "Debug mode can be entered by asserting the external signal debug_req_i\ncause is set to = 3 (also see verification goal)",
        "Verification Goal": "Assert debug_req_i while executing arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=debugger(0x3))\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Enter DEBUG mode",
        "Sub Feature": "External debug event",
        "Feature Description": "Debug mode can be entered by asserting the external signal debug_req_i\ncause is set to = 3 (also see verification goal)",
        "Verification Goal": "Assert debug_req_i while executing arbitrary code\nVerify that:\nCore switches into debug mode.\nCurrent PC must be saved to DPC\nCause of debug must be saved to DCSR (cause=debugger(0x3))\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ext\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_mode_ext_req\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_mode_pc\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "The CV32E40P contains a trigger module with a single trigger register capable of triggering on instruction address match.\nWrite '1' to tdata1[2] to enable matching\nWrite breakpoint addr to tdata2 register\ncause = 2",
        "Verification Goal": "Verify that core enters debug mode when the trigger matches on instruction address. NB! According to spec, the tdataN registers can only be written from debug mode, as m-mode writes are ignored.\n\nEnter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and enable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core enters debug mode on breakpoint addr\nCurrent PC is saved to DPC\nCause of debug must be saved to DCSR (cause=2)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "The CV32E40P contains a trigger module with a single trigger register capable of triggering on instruction address match.\nWrite '1' to tdata1[2] to enable matching\nWrite breakpoint addr to tdata2 register\ncause = 2",
        "Verification Goal": "Verify that core enters debug mode when the trigger matches on instruction address. NB! According to spec, the tdataN registers can only be written from debug mode, as m-mode writes are ignored.\n\nEnter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and enable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core enters debug mode on breakpoint addr\nCurrent PC is saved to DPC\nCause of debug must be saved to DCSR (cause=2)\nPC is updated to value on dm_haltaddr_i input\nCore starts executing debug code",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_match\nA:   uvmt_cv32_tb.u_debug_assert.a_trigger_match\nA:  uvmt_cv32_tb.u_debug_assert.a_debug_mode_pc\nA:  uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "When trigger module is disabled, no trigger should fire even though the PC matches the address in tdata2.",
        "Verification Goal": "Enter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and disable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core does not enter debug mode on breakpoint addr\n",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac\n\nRISCV-V External Debug Support Version 0.13.2",
        "Requirement Location": "Debug chapter \n\n\n\nChapter 5",
        "Feature": "Trigger module",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "When trigger module is disabled, no trigger should fire even though the PC matches the address in tdata2.",
        "Verification Goal": "Enter debug mode by any of the above methods.\nWrite (randomized) breakpoint addr to tdata2 and disable breakpoint in tdata1[2]\nExit debug mode (dret instruction)\nVerify that core does not enter debug mode on breakpoint addr\n",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: cg_trigger_match_disabled\nA:   uvmt_cv32_tb.u_debug_assert.a_trigger_match_disabled\n",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Debug exception addr",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "If an exception occurs during debug mode, the PC should be set to the dm_exception_addr_i input without changing the status registers",
        "Verification Goal": "Bring core into debug mode, generate all exception types and observe that the PC jumps to the address given by dm_exception_addr_i. Observe no change in status registers\nAccording to specification, the cf32e40p supports the following types of exceptions:\nIllegal instruction (2)\nBreakpoint (3)\nEnvironment call from M-mode (ECALL) (11)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Debug exception addr",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "If an exception occurs during debug mode, the PC should be set to the dm_exception_addr_i input without changing the status registers",
        "Verification Goal": "Bring core into debug mode, generate all exception types and observe that the PC jumps to the address given by dm_exception_addr_i. Observe no change in status registers\nAccording to specification, the cf32e40p supports the following types of exceptions:\nIllegal instruction (2)\nBreakpoint (3)\nEnvironment call from M-mode (ECALL) (11)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_exception\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ecall\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_mode_exception",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Core debug registers",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "Accessing the core debug registers - DCSR, DPC and DSCRATCH0/1 while NOT in debug mode causes an illegal instruction",
        "Verification Goal": "Access all debug registers in M-mode and observe that illegal instruction exception is triggered.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Non-Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Core debug registers",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "Accessing the core debug registers - DCSR, DPC and DSCRATCH0/1 while NOT in debug mode causes an illegal instruction",
        "Verification Goal": "Access all debug registers in M-mode and observe that illegal instruction exception is triggered.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_regs_m_mode\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_regs_mmode",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Trigger module registers",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "Accessing the trigger module registers - tselect, tdata1/2/3 are readable from M-mode, but not writeable.",
        "Verification Goal": "Access all trigger module registers in M-mode and observe writes have no effects and reads should reflect register content.\n\nAccess registers from D-mode and observe full R/W access.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "CV32E40P doc rev 46711ac",
        "Requirement Location": "Debug chapter",
        "Feature": "Trigger module registers",
        "Sub Feature": "Trigger module match event",
        "Feature Description": "Accessing the trigger module registers - tselect, tdata1/2/3 are readable from M-mode, but not writeable.",
        "Verification Goal": "Access all trigger module registers in M-mode and observe writes have no effects and reads should reflect register content.\n\nAccess registers from D-mode and observe full R/W access.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_regs\n",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt2",
        "Feature": "Program Buffer",
        "Sub Feature": "Interrupts",
        "Feature Description": "While in debug mode and executing from the program buffer, all interrupts are masked.",
        "Verification Goal": "Enable interrupts (setting mstatus.mie field and mie register).\nBring core into debug mode and start executing from program buffer.\nGenerate interrupts while in debug mode and ensure they are masked.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt2",
        "Feature": "Program Buffer",
        "Sub Feature": "Interrupts",
        "Feature Description": "While in debug mode and executing from the program buffer, all interrupts are masked.",
        "Verification Goal": "Enable interrupts (setting mstatus.mie field and mie register).\nBring core into debug mode and start executing from program buffer.\nGenerate interrupts while in debug mode and ensure they are masked.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_in_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_irq_in_debug",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt3",
        "Feature": "Program Buffer",
        "Sub Feature": "Exceptions",
        "Feature Description": "While in debug mode and executing from the program buffer, exceptions don\u2019t update any registers but they DO end execution of PB (TBD: goes back to M-mode or restarts in debug(?)) [PZ] this is redundnant with dm_exception_addr_i (on line 10 & 11)",
        "Verification Goal": "Bring core into debug mode and start executing from program buffer. Make sure PB includes code that will hit an exception. Make sure core doesn\u2019t update any registers, and jumps out of debug mode into M-mode",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt3",
        "Feature": "Program Buffer",
        "Sub Feature": "Exceptions",
        "Feature Description": "While in debug mode and executing from the program buffer, exceptions don\u2019t update any registers but they DO end execution of PB (TBD: goes back to M-mode or restarts in debug(?)) [PZ] this is redundnant with dm_exception_addr_i (on line 10 & 11)",
        "Verification Goal": "Bring core into debug mode and start executing from program buffer. Make sure PB includes code that will hit an exception. Make sure core doesn\u2019t update any registers, and jumps out of debug mode into M-mode",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt4",
        "Feature": "Program Buffer",
        "Sub Feature": "Triggers",
        "Feature Description": "While in debug mode and executing from the program buffer, no action is taken on any trigger match.",
        "Verification Goal": "Bring core into debug and enable a trigger on the PC (pointing to the debug program buffer). Continue execution in debug, and observe that no action is taken when the trigger matches.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt4",
        "Feature": "Program Buffer",
        "Sub Feature": "Triggers",
        "Feature Description": "While in debug mode and executing from the program buffer, no action is taken on any trigger match.",
        "Verification Goal": "Bring core into debug and enable a trigger on the PC (pointing to the debug program buffer). Continue execution in debug, and observe that no action is taken when the trigger matches.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_trigger_match_disabled (d_match_with_en)",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt5",
        "Feature": "Program Buffer",
        "Sub Feature": "Counters",
        "Feature Description": "Spec:Counters may be stopped, depending on stopcount in dscr\nFor CV32E40P, stopcount not implemented, counters are not stopped during debug.",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this.\n\n[PZ] We will need a test to ensure counters do not stop couting in debug mode. We cannot disable counters as stopcount is not implemented.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt5",
        "Feature": "Program Buffer",
        "Sub Feature": "Counters",
        "Feature Description": "Spec:Counters may be stopped, depending on stopcount in dscr\nFor CV32E40P, stopcount not implemented, counters are not stopped during debug.",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this.\n\n[PZ] We will need a test to ensure counters do not stop couting in debug mode. We cannot disable counters as stopcount is not implemented.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_counters_enabled\nA:   uvmt_cv32_tb.u_debug_assert.a_minstret_count\nA:   uvmt_cv32_tb.u_debug_assert.a_mcycle_count",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt6",
        "Feature": "Program Buffer",
        "Sub Feature": "Timers",
        "Feature Description": "Timers may be stopped, depending on stoptime in dcsr",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this.  [PZ] I confirm that this is not needed on CV32E40P. There is no timer in CV32E40P.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt7",
        "Feature": "Program Buffer",
        "Sub Feature": "WFI instruction",
        "Feature Description": "In debug, the WFI instruction acts as a NOP instruction",
        "Verification Goal": "Bring core into debug mode. Ensure that an WFI instruction will be executed from the program buffer. Ensure that the WFI will act as a nop, not waiting for an interrupt to occur.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt7",
        "Feature": "Program Buffer",
        "Sub Feature": "WFI instruction",
        "Feature Description": "In debug, the WFI instruction acts as a NOP instruction",
        "Verification Goal": "Bring core into debug mode. Ensure that an WFI instruction will be executed from the program buffer. Ensure that the WFI will act as a nop, not waiting for an interrupt to occur.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_wfi_in_debug\nA:   uvmt_cv32_tb.u_debug_assert.a_wfi_in_debug",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt8",
        "Feature": "Program Buffer",
        "Sub Feature": "Priv. lvl changes",
        "Feature Description": "An ebreak instruction during debug shall result in relaunching the debugger entry code by setting the PC to the halt_addr_i and will not change any CSR in doing this.",
        "Verification Goal": "Bring hart into debug mode and start executing from the Program Buffer. Make sure the PB code includes an ebreak instruction. When the ebreak is executed, the hart must halt and not update dpc or dcsr. Ensure relaunch of debugger entry",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt8",
        "Feature": "Program Buffer",
        "Sub Feature": "Priv. lvl changes",
        "Feature Description": "An ebreak instruction during debug shall result in relaunching the debugger entry code by setting the PC to the halt_addr_i and will not change any CSR in doing this.",
        "Verification Goal": "Bring hart into debug mode and start executing from the Program Buffer. Make sure the PB code includes an ebreak instruction. When the ebreak is executed, the hart must halt and not update dpc or dcsr. Ensure relaunch of debugger entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_ebreak_with_ebreakm (.ebreak_in_debug)\nCG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_cebreak_with_ebreakm (.ebreak_in_debug)\nA:   uvmt_cv32_tb.u_debug_assert.a_ebreak_during_debug_mode\nA:   uvmt_cv32_tb.u_debug_assert.a_cebreak_during_debug_mode",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt9",
        "Feature": "Program Buffer",
        "Sub Feature": "Fence instructions",
        "Feature Description": "Completing program buffer execution is considered output for the purpose of the fence instruction.",
        "Verification Goal": "TBD - need to understand the fence instruction in cv32e40p. Is \"completing program buffer execution\" the same as executing dret? [PZ] waiting for more clarity from RISCV Foundation debug task group (see https://lists.riscv.org/g/tech-debug/topic/clarification_request/75725318?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,75725318 )",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Fence and fence.i executed during debug mode in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt9",
        "Feature": "Program Buffer",
        "Sub Feature": "Fence instructions",
        "Feature Description": "Completing program buffer execution is considered output for the purpose of the fence instruction.",
        "Verification Goal": "TBD - need to understand the fence instruction in cv32e40p. Is \"completing program buffer execution\" the same as executing dret? [PZ] waiting for more clarity from RISCV Foundation debug task group (see https://lists.riscv.org/g/tech-debug/topic/clarification_request/75725318?p=,,,20,0,0,0::recentpostdate%2Fsticky,,,20,2,0,75725318 )",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_fence_in_debug",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt10",
        "Feature": "Program Buffer",
        "Sub Feature": "Ctrl. Transfer instr.",
        "Feature Description": "All control transfer instructions may act as illegal instructions if destination is within program buffer. If one does, all must.",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40P debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt11",
        "Feature": "Program Buffer",
        "Sub Feature": "Ctrl. Transfer instr.",
        "Feature Description": "All control transfer instructions may as illegal instructions if destination is outside the program buffer. If one does, all must.",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40P debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt12",
        "Feature": "Program Buffer",
        "Sub Feature": "Instr. Dependent of PC",
        "Feature Description": "Instructions that depend on the PC may act as illegal instructions",
        "Verification Goal": "N/A for CV32E40P : need Arjan/Davide to sign-off on this. [PZ] This is not supported and it is mentioned in the CV32E40P debug spec. No verification needed to prove nor dis-prove this behavior",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt13",
        "Feature": "Program Buffer",
        "Sub Feature": "Effective XLEN",
        "Feature Description": "Effective XLEN = DXLEN",
        "Verification Goal": "CV32E40P XLEN=1 (32 bits).  DXLEN is defined as the widest supported XLEN. For now, this will be 1 (32 bits). Check XLEN M- and D-mode\nMike: what exactly would a testcase actually do to check this?\n\u00d8K: As discussed in the meeting 02.July, this is probably a SW/DM problem. Leaving it here for reference.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.1 Debug mode pt13",
        "Feature": "Program Buffer",
        "Sub Feature": "Effective XLEN",
        "Feature Description": "Effective XLEN = DXLEN",
        "Verification Goal": "CV32E40P XLEN=1 (32 bits).  DXLEN is defined as the widest supported XLEN. For now, this will be 1 (32 bits). Check XLEN M- and D-mode\nMike: what exactly would a testcase actually do to check this?\n\u00d8K: As discussed in the meeting 02.July, this is probably a SW/DM problem. Leaving it here for reference.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.2 Load-Reserved/Store-Conditional",
        "Feature": "Program Buffer",
        "Sub Feature": "Effective XLEN",
        "Feature Description": "Effective XLEN = DXLEN",
        "Verification Goal": "N/A for CV32E40P (requires A-extention) : need Arjan/Davide to sign-off on this. [PZ] This is not a test but a warning or assumption that debug entry should not occur between a lr and sc instruction pair. Moreover, CV32E40P does not support A-extension",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.3 Wait for interrupt",
        "Feature": "Debug mode",
        "Sub Feature": "WFI instruction",
        "Feature Description": "If debug_req_i is asserted while waiting for interrupt (core_sleep_o = 1), WFI instruction must complete (core_sleep_o -> 0) and hart enters debug mode.",
        "Verification Goal": "Insert WFI instruction into arbitrary code. While the hart is waiting for an interrupt, request debug mode. The hart must stop waiting for interrupt and enter debug mode. WFI at trigger will be converted to a NOP and should be a dedicated test. See #pz_ref2 in this sheet below",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.3 Wait for interrupt",
        "Feature": "Debug mode",
        "Sub Feature": "WFI instruction",
        "Feature Description": "If debug_req_i is asserted while waiting for interrupt (core_sleep_o = 1), WFI instruction must complete (core_sleep_o -> 0) and hart enters debug mode.",
        "Verification Goal": "Insert WFI instruction into arbitrary code. While the hart is waiting for an interrupt, request debug mode. The hart must stop waiting for interrupt and enter debug mode. WFI at trigger will be converted to a NOP and should be a dedicated test. See #pz_ref2 in this sheet below",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_wfi_debug_req",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "By setting step in dcsr[2] before resuming execution, a debugger can cause the hart to execute a single instructin before re-entering debug mode.",
        "Verification Goal": "Bring the hart into debug mode. Set the step bit in dcsr[2] and then resume execution. Observe that the hart runs a single instruction and the goes back to debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "By setting step in dcsr[2] before resuming execution, a debugger can cause the hart to execute a single instructin before re-entering debug mode.",
        "Verification Goal": "Bring the hart into debug mode. Set the step bit in dcsr[2] and then resume execution. Observe that the hart runs a single instruction and the goes back to debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step casues an exception, debug mode is entered immediately after the PC is changed to the exception handler and registers tval and cause are updated.\n\nNote: CV32E40P does not support tval (this should be supported in future cores)",
        "Verification Goal": "Perform a single step. Make sure the instruction executed in the step will cause an exception. PC must jump to the exception handler address and update tval and cause and then immediately enter debug mode.\n\nCheck tval==0, then on future cores, when implemented, it will fail and require a test update",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step casues an exception, debug mode is entered immediately after the PC is changed to the exception handler and registers tval and cause are updated.\n\nNote: CV32E40P does not support tval (this should be supported in future cores)",
        "Verification Goal": "Perform a single step. Make sure the instruction executed in the step will cause an exception. PC must jump to the exception handler address and update tval and cause and then immediately enter debug mode.\n\nCheck tval==0, then on future cores, when implemented, it will fail and require a test update",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_illegal)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step_exception",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step causes a trigger, debug mode is entered immediately after the trigger fired. Cause is set to 2 instead of 4",
        "Verification Goal": "Set up the trigger module to match on instruction address. Set up single stepping such that the match address will be executed in a step. The trigger module must fire during the step, and debug mode entered with cause = 2 to identify that the trigger was fired. (#1)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the instruction being fetched or executed in a single step causes a trigger, debug mode is entered immediately after the trigger fired. Cause is set to 2 instead of 4",
        "Verification Goal": "Set up the trigger module to match on instruction address. Set up single stepping such that the match address will be executed in a step. The trigger module must fire during the step, and debug mode entered with cause = 2 to identify that the trigger was fired. (#1)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_trigger_match)\nA:    uvmt_cv32_tb.u_debug_assert.a_single_step_trigger\nA:   uvmt_cv32_tb.u_debug_assert.a_enter_debug",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause an exception, the exception will not execute until the next time the hart resumes.",
        "Verification Goal": "Make sure that an instruction in the instruction memory will generate a PC that causes an exception. Set up single stepping and make sure to step through this specific instruction. Hart must go back to debug mode after stepping, and the exception must not start executing until the next time the hart resumes (either single step or exit debug mode)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause an exception, the exception will not execute until the next time the hart resumes.",
        "Verification Goal": "Make sure that an instruction in the instruction memory will generate a PC that causes an exception. Set up single stepping and make sure to step through this specific instruction. Hart must go back to debug mode after stepping, and the exception must not start executing until the next time the hart resumes (either single step or exit debug mode)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause a trigger event, the trigger event will not take place until the instruction is executed.",
        "Verification Goal": "This can be verified in the same steps as marked with (#1).\nMike: this may be difficult to accurately predict in the ISS.  This is good input for the Imperas team.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the intruction executed in the single step results in a PC that will cause a trigger event, the trigger event will not take place until the instruction is executed.",
        "Verification Goal": "This can be verified in the same steps as marked with (#1).\nMike: this may be difficult to accurately predict in the ISS.  This is good input for the Imperas team.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_next_pc_will_match)",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the single step instruction is WFI, it must be treated as a nop instead of stalling and waiting for interrupt. [PZ] #pz_ref2",
        "Verification Goal": "Perform a single step where the instruction to be executed is a WFI instruction. The hart must not wait for interrupt, but treat the instruction as as NOP and re-enter debug after finishing the step.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.4 Single step",
        "Feature": "Debug mode",
        "Sub Feature": "Single stepping",
        "Feature Description": "If the single step instruction is WFI, it must be treated as a nop instead of stalling and waiting for interrupt. [PZ] #pz_ref2",
        "Verification Goal": "Perform a single step where the instruction to be executed is a WFI instruction. The hart must not wait for interrupt, but treat the instruction as as NOP and re-enter debug after finishing the step.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (.mmode_step_wfi)\nA:   uvmt_cv32_tb.u_debug_assert.a_single_step_wfi",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.5 Reset",
        "Feature": "Debug mode",
        "Sub Feature": "Reset",
        "Feature Description": "When the hart comes out of reset, it must immediately enter debug mode without executing any instructions if the halt signal or debug_req_i is asserted.",
        "Verification Goal": "Assert the core reset AND the debug_req_i signal. The hart must not execute any instructions, but immediately enter debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_reset\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.5 Reset",
        "Feature": "Debug mode",
        "Sub Feature": "Reset",
        "Feature Description": "When the hart comes out of reset, it must immediately enter debug mode without executing any instructions if the halt signal or debug_req_i is asserted.",
        "Verification Goal": "Assert the core reset AND the debug_req_i signal. The hart must not execute any instructions, but immediately enter debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_at_reset\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_at_reset",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while NOT in debug mode will cause an illegal instruction exception.",
        "Verification Goal": "Insert dret into arbitrary code running in m-mode, observe that the illegal insctruction exception is thrown.\nCan be tested in the same test as for debug entry",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while NOT in debug mode will cause an illegal instruction exception.",
        "Verification Goal": "Insert dret into arbitrary code running in m-mode, observe that the illegal insctruction exception is thrown.\nCan be tested in the same test as for debug entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_mmode_dret\nA:  uvmt_cv32_tb.u_debug_assert.a_mmode_dret",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while in debug mode will restore PC to the value in dpc and exit debug mode. (privilege level will be restored to the value in dcsr).\nNote: CV32E40P only supports machine mode.",
        "Verification Goal": "Bring hart into debug mode. Execute a dret instruction and observe that the hart resumes executing from the correct address as given by dpc. \nCan be tested in the same test as for debug entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2",
        "Requirement Location": "4.6 dret instruction",
        "Feature": "Debug mode",
        "Sub Feature": "dret instruction",
        "Feature Description": "Executing dret while in debug mode will restore PC to the value in dpc and exit debug mode. (privilege level will be restored to the value in dcsr).\nNote: CV32E40P only supports machine mode.",
        "Verification Goal": "Bring hart into debug mode. Execute a dret instruction and observe that the hart resumes executing from the correct address as given by dpc. \nCan be tested in the same test as for debug entry.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_mmode_dret\nA:   uvmt_cv32_tb.u_debug_assert.a_dmode_dret",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Semihosting",
        "Sub Feature": "dret instruction",
        "Feature Description": "To enable semihosting, a special instruction sequence is needed as there is only a single EBREAK instruction available.\n\nslli x0, x0, 0x1f # Entry NOP\nebreak # Break to debugger\nsrai x0, x0, 7 # NOP encoding the semihosting call number 7\n\n[PZ] This is a software convention and need not be tested in verification. As long as the above instructions work in general, then no need for dedicated semihosting testing.",
        "Verification Goal": "If all points above passes, there should be nothing to verify here. Semihosting will be handled from SW.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "N/A",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Trigger",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. When the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With timing=0 the core will not attempt to execute instruction at trigger address",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Trigger",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. When the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With timing=0 the core will not attempt to execute instruction at trigger address",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Trigger, single step",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. \nSet up single stepping such that the match address will be executed in the next step.\nWhen the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With timing=0 the core will not attempt to execute instruction at trigger address",
        "": ""
    },
    {
        "Reference document": "RISC-V ISM vol 1 (unpriv. ISA), 20191213",
        "Requirement Location": "Section 2.8\n\n\nDebug chapter",
        "Feature": "Trigger, single step",
        "Sub Feature": "Exception handling",
        "Feature Description": "If the trigger matches on an illegal instruction, PC must be set to the exception handler prior to entering debug mode.",
        "Verification Goal": "Set up the trigger to match on an address containing an illegal instruction. \nSet up single stepping such that the match address will be executed in the next step.\nWhen the trigger fires, ensure that cause=0x2(trigger) and that PC is set to the exception handler before entering debug mode.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "With timing=0 the core will not attempt to execute instruction at trigger address",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "Single step",
        "Sub Feature": "Interrupts",
        "Feature Description": "While single stepping, interrupts may be enabled or disabled using the dcsr.stepie bit. ",
        "Verification Goal": "Set up single stepping. Ensure interrupt is asserted while performing a step. Ensure that the interrupt is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "Single step",
        "Sub Feature": "Interrupts",
        "Feature Description": "While single stepping, interrupts may be enabled or disabled using the dcsr.stepie bit. ",
        "Verification Goal": "Set up single stepping. Ensure interrupt is asserted while performing a step. Ensure that the interrupt is taken when dcsr.stepie = 1, and not taken when dcsr.stepie = 0.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_single_step (mmode_step_stepie)",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "Single step",
        "Sub Feature": "Interrupts",
        "Feature Description": "While single stepping, interrupts may be enabled or disabled using the dcsr.stepie bit. ",
        "Verification Goal": "Have debug_req_i and interrupt asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the interrupt exception address)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "Single step",
        "Sub Feature": "Interrupts",
        "Feature Description": "While single stepping, interrupts may be enabled or disabled using the dcsr.stepie bit. ",
        "Verification Goal": "Have debug_req_i and interrupt asserted on same clock cycle. Ensure debugger entered with PC reflecting normal PC thread (not the interrupt exception address)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_dreq\nA:   uvmt_cv32_tb.u_debug_assert.a_debug_req_and_irq",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] Run RISCV compliance tests all in debug mode",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Waived",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] assert debug_req and interrupt at the same time as trigger is matching an address (with trigger enabled) and the instruction being 1) illegal instruction 2) exception call (e.g. ebreak with ebreakm==0) 3) branch 4) multicycle instruction (e.g. mulh)",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC \"debug_test_trigger\"",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] assert debug_req and interrupt at the same time as trigger is matching an address (with trigger enabled) and the instruction being 1) illegal instruction 2) exception call (e.g. ebreak with ebreakm==0) 3) branch 4) multicycle instruction (e.g. mulh)",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_irq_dreq\n        (.irq_dreq_trig_ill/cebreak/ebreak/branch/multicycle)\n",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] Add coverage to ensure debug_req asserted on every FSM state",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.cg_debug_mode_ext\n",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] Have trigger address match an instruction that has an illegal instruction (both in normal and single step mode). Ensure debug is enterred with cause set to trigger and PC is set to exception handler prior to debug entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not possible with timing=0, core will not execute instruction at match address before entering debug mode.",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "All RISCV code should run in debug mode as well as M mode",
        "Verification Goal": "[PZ] Have trigger address match an instruction that has an illegal instruction (both in normal and single step mode). Ensure debug is enterred with cause set to trigger and PC is set to exception handler prior to debug entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not possible with timing=0, core will not execute instruction at match address before entering debug mode.",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "If a debug_req_i is asserted when an illegal instructions is being executed, the address of the trap handler must be stored to dpc instead of the address of the illegal instruction",
        "Verification Goal": "[PZ] Have trigger address match an instruction that has an illegal instruction (both in normal and single step mode). Ensure debug is enterred with cause set to trigger and PC is set to exception handler prior to debug entry",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_known_miscompares",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "If a debug_req_i is asserted when an illegal instructions is being executed, the address of the trap handler must be stored to dpc instead of the address of the illegal instruction",
        "Verification Goal": "[PZ] Have trigger address match an instruction that has an illegal instruction (both in normal and single step mode). Ensure debug is enterred with cause set to trigger and PC is set to exception handler prior to debug entry",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "A: uvmt_cv32_tb.u_debug_assert.a_illegal_insn_debug_req",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "Several causes exist for entering debug, the priority is as follows:\n1: Trigger match\n2: Ebreak\n3: Reset halt request\n4: Halt request\n5: Single step",
        "Verification Goal": "Ensure combinations of reasons exist simultaneously, and observer that the correct cause is stored to dcsr.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Partly covered in DTC \"debug_test\" and \"debug_test_trigger\", the rest will be covered by corev_rand_debug_ebreak and corev_rand_debug_single_step",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "RISCV compliance",
        "Sub Feature": "Interrupts",
        "Feature Description": "Several causes exist for entering debug, the priority is as follows:\n1: Trigger match\n2: Ebreak\n3: Reset halt request\n4: Halt request\n5: Single step",
        "Verification Goal": "Ensure combinations of reasons exist simultaneously, and observer that the correct cause is stored to dcsr.",
        "Pass/Fail Criteria": "Check against ISS",
        "Test Type": "Constrained-Random",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "CG: uvm_pkg.uvm_test_top.env.cov_model.debug_covg.debug_causes\n        (.trig_vs_ebreak, trig_vs_cebreak, trig_vs_dbg_req, trig_vs_step\n          ebreak_vs_req, cebreak_vs_req, ebreak_vs_step, cebreak_vs_step, dbg_req_vs_step)",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": "4.8.1 DCSR\n\nControl and Status Registers",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    },
    {
        "Reference document": "RISC-V External Debug Support Version 0.13.2\nCV32E40P doc rev 46711ac",
        "Requirement Location": " -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- END -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
        "Feature": "External debug request",
        "Sub Feature": "Startup / clock gating",
        "Feature Description": "When the reset signal is deasserted, but before the fetch_enable_i signal is active, the internal clock of the core is gated. An issue in the cv32e40p repo describes a scenario where a short pulse of debug_req_i could be missed due to the clock gating.",
        "Verification Goal": "Assert short (1 cycle) debug_req_i randomly after reset, before the core starts executing. Observe that the core enters debug mode without executing any instructions prior to entry.",
        "Pass/Fail Criteria": "Self Checking Test",
        "Test Type": "Directed Self-Checking",
        "Coverage Method": "Testcase",
        "Link to Coverage": "Covered in DTC debug_test_boot_set",
        "": ""
    }
]