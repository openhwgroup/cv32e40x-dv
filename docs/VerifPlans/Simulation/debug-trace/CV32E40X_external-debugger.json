[
    {
        "Requirement reference": "Privileged ISA Version 20190608-Priv-MSU-Ratified",
        "Requirement Location": "Section 3.2.1: Environment Call and Breakpoint ",
        "Feature": "Privileged Debugger Breakpoint",
        "Sub-Feature": "(Machine-Mode) ebreak\npush PC -> MEPC\n(debugmode) mret\npop MEPC -> PC",
        "Feature Description": "ebreak instruction switches core into Debug-Mode synchronously: \nmepc = address of ebreak instruction.\nPC = mepc on return form exception.",
        "Verification Goal": "add ebreak to arbitrary Machine-Mode code in wide-range of  locations. \nVerify return to User-Mode after execution.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode.\nVerification that CSR/DCSR and PC/DPC registers are updated as expected",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 10.1: Machine Status (MSTATUS)\nSection 10.5: Machine Exception PC (MEPC)\n",
        "Feature": "Machine Exception PC register",
        "Sub-Feature": "(Machine-Mode) ebreak\npush PC -> MEPC\n(debugmode) mret\npop MEPC -> PC",
        "Feature Description": "ebreak instruction switches core  into Debug-Mode synchronously: \n mepc = address of ebreak instruction on entry. \nPC = mepc on return form exception.\n\nif User-Mode enabled when Machine-Mode ebreak exception occurs, UPIE (MSTATUS[4]) = UIE (USTATUS[0]). PC = mepc on execution of mret (return form exception), UIE(MSTATUS[0]) = MPIE(MSTATUS[4]).",
        "Verification Goal": "add ebreak to arbitrary Machine-Mode code in wide-range of  locations. \nVerify return to User-Mode after execution.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "Unprivileged ISA 20190608-Base-Ratified",
        "Requirement Location": "Section 2.8: Environment Call and Breakpoints\nSection 25: RV32/64G Instruction Set Listings",
        "Feature": "Unprivileged Debugger Breakpoint",
        "Sub-Feature": "(User-Mode) ebrake \npush PC -> UEPC\n(debugmode) mret\npop UEPC -> PC",
        "Feature Description": "ebreak instruction switches core  into Debug-Mode synchronously: uepc = address of ebreak instruction on entry, UPIE (USTATUS[4]) = UIE (USTATUS[0]). PC = mepc on execution of uret (return form exception, UIE(USTATUS[0]) = UPIE(USTATUS[4]).",
        "Verification Goal": "add ebreak to arbitrary User-Mode code in wide-range of  locations. \nVerify return to User-Mode after execution.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 10.2: User Status (USTATUS)\nSection 10.6: User Exception PC (UEPC)",
        "Feature": "User Exception PC register",
        "Sub-Feature": "(User-Mode) ebrake \npush PC -> UEPC\n(debugmode) mret\npop UEPC -> PC",
        "Feature Description": "ebreak instruction switches core  into Debug-Mode synchronously: uepc = address of ebreak instruction on entry, UPIE (USTATUS[4]) = UIE (USTATUS[0]). PC = mepc on execution of uret (return form exception, UIE(USTATUS[0]) = UPIE(USTATUS[4]).",
        "Verification Goal": "add ebreak to arbitrary User-Mode code in wide-range of  locations. \nVerify DPC address is that of the ebreak instruction.\nVerify return to User-Mode after execution.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "Unprivileged ISA 20190608-Base-Ratified",
        "Requirement Location": "Section 2.8: Environment Call and Breakpoints\nSection 25: RV32/64G Instruction Set Listings",
        "Feature": "Unprivileged Debugger Breakpoint",
        "Sub-Feature": "U-Mode ebreak \"semihosting\"",
        "Feature Description": "to support \"Semihosting\", a special instruction sequence used to enable \u201cSemihosting\u201d  (communicate-with and use I/O of ext. host computer) over system call interface: \n   slli x0, x0, 0x1f    # Entry NOP\n   ebreak                    # Break to debugger\n   srai x0, x0, 7          # NOP encoding semihosting call #7",
        "Verification Goal": "add speciual \"semihosting\" ebreak instruction sequence to arbitrary User-Mode code in wide-range of  locations.\nVerify ext. host computer I/O transactions.  \nVerify DPC address is that of the ebreak instruction.\nVerify return to User-Mode after execution.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering \"semihosting\"; during \"semihosting\"; and after exiting \"semihosting\"",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.3: Wait for Interrupt Instruction ",
        "Feature": "graceful Debug-Mode from WFI",
        "Sub-Feature": "U-Mode ebreak \"semihosting\"",
        "Feature Description": "Debug-Mode can be entered via an ebreak exception or a debug_req_i  interrupt. if either is requested while an interrupt is already beings services, Debug-Mode will  be entered after completion of wait-for-interrupt (wfi)",
        "Verification Goal": "Verify that Debug only enters after completion of wait-for-interrupt (wfi)",
        "Pass/Fail Critiera": "Self-checking against five expected results: before entering interrupt; at the beginning of interrupt; after the Debug-Mode while still in the interrupt; after exiting the interrupt; in Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "Privileged ISA Version 20190608-Priv-MSU-Ratified",
        "Requirement Location": "Section 1.3: Debug Mode \nSection 2.1: CSR Address Mapping Conventions",
        "Feature": "Debug-Mode only Debug-CSRs and memory address space",
        "Sub-Feature": "U-Mode ebreak \"semihosting\"",
        "Feature Description": "Debug-Mode CSR and DM_HaltAddress and range exclusively accessible in Debug mode.  \ndebug_req_i switches core  into Debug-Mode jumping to DM_HaltAddress & storing next instruction addr. in DPC\n|------------------|-----------------------------------------------|\n|Address (Hex) |                  Use & Accessibility                     |\n|------------------|-----------------------------------------------|\n| 0x7B0-0x7BF   |Debug-mode-only CSRs                             |\n|   *_TBD_*          |DM_HaltAddress                                           |\n|------------------|-----------------------------------------------|\nIllegal instruction exception shall be raised on non-Debug-Mode access.\n\ndret instruction changes pc to value stored in dpc, privilege-level changed to prv in dcsr, then hart exits Debug-Mode. ",
        "Verification Goal": "Verify exclusive Debug-Mode memory address space can only be accessed in Debug-Mode.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; after jump to DM_HaltAddress; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 13: Debug Unit ",
        "Feature": "Debug Request Interrupt",
        "Sub-Feature": "debug_req_i interrupt jumping to \"DM_HaltAddress\"",
        "Feature Description": "Debug-Mode CSR and DM_HaltAddress and range exclusively accessible in Debug mode.  \ndebug_req_i switches core  into Debug-Mode jumping to DM_HaltAddress & storing next instruction addr. in DPC\n|------------------|-----------------------------------------------|\n|Address (Hex) |                  Use & Accessibility                     |\n|------------------|-----------------------------------------------|\n| 0x7B0-0x7BF   |Debug-mode-only CSRs                             |\n|   *_TBD_*          |DM_HaltAddress                                           |\n|------------------|-----------------------------------------------|\nIllegal instruction exception shall be raised on non-Debug-Mode access.\n\ndret instruction changes pc to value stored in dpc, privilege-level changed to prv in dcsr, then hart exits Debug-Mode. ",
        "Verification Goal": "Verify DM_HaltAddress program, including data sections and exception tables must fit in 1Mbyte space starting at address 0; address DM_HALTADDRESS must exist in the memory map; and should have executable code producing predictable result.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; after jump to DM_HaltAddress; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.6: dret Instruction ",
        "Feature": "Return from Debug-Mode instruction",
        "Sub-Feature": "debug_req_i interrupt jumping to \"DM_HaltAddress\"",
        "Feature Description": "Debug-Mode CSR and DM_HaltAddress and range exclusively accessible in Debug mode.  \ndebug_req_i switches core  into Debug-Mode jumping to DM_HaltAddress & storing next instruction addr. in DPC\n|------------------|-----------------------------------------------|\n|Address (Hex) |                  Use & Accessibility                     |\n|------------------|-----------------------------------------------|\n| 0x7B0-0x7BF   |Debug-mode-only CSRs                             |\n|   *_TBD_*          |DM_HaltAddress                                           |\n|------------------|-----------------------------------------------|\nIllegal instruction exception shall be raised on non-Debug-Mode access.\n\ndret instruction changes pc to value stored in dpc, privilege-level changed to prv in dcsr, then hart exits Debug-Mode. ",
        "Verification Goal": "verify that dret outside Debug-Mode causes illegal instruction exception.",
        "Pass/Fail Critiera": "Self-checking against three expected results: before entering Debug-Mode; after jump to DM_HaltAddress; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "Privileged ISA Version 20190608-Priv-MSU-Ratified",
        "Requirement Location": "Section 2.2: CSR Listing ",
        "Feature": "Debug-Mode CSR addresses and access restrictions",
        "Sub-Feature": "debug_req_i interrupt jumping to \"DM_HaltAddress\"",
        "Feature Description": "* Table 2.6: Allocated RISC-V CSR addresses.\n|--------|------------|--------------------------------------------|\n|  Addr | Name       |    Use & Accessibility                              |\n|--------|------------|--------------------------------------------|\n| 0x7B0 |dcsr           |D-Mode Debug Control & Status reg|\n| 0x7B1 |dpc            |D-Mode Debug PC                                    |\n| 0x7B2 |dscratch0|D-Mode Debug scratch reg 0                |\n| 0x7B3 |dscratch1|D-Mode Debug scratch reg 1                |\n|--------|------------|--------------------------------------------|",
        "Verification Goal": "Verify Debug CSR only accessible in Debug-Mode. \nIllegal instruction exception raised on non-Debug-Mode access.",
        "Pass/Fail Critiera": "Self-checking access expected illegal instruction exception by trying to access when not in Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 10.13: Debug Control and Status (DCSR)  ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DCSR",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify DCSR fields can be updated and that read/write permissions are respected. ",
        "Pass/Fail Critiera": "Self-checking of DCSR expected values.",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4 .8.1: Debug Control and Status (dcsr, at 0x7b0) ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DCSR",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify DCSR fields can be updated and that read/write permissions are respected. ",
        "Pass/Fail Critiera": "Self-checking of DCSR expected values.",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 10.14: DPC ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DPC",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify that DPC contains address of next instruction to be executed if Debug Mode would not have been entered.",
        "Pass/Fail Critiera": "Self-checking of DPC and PC against three expected values: before entering Debug-Mode; while in Debug-Mode; and after exiting Debug-Mode ",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.8.2: Debug PC (dpc, at 0x7b1) ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DPC",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify that DPC contains address of next instruction to be executed if Debug Mode would not have been entered.",
        "Pass/Fail Critiera": "Self-checking of DPC and PC against three expected values: before entering Debug-Mode; while in Debug-Mode; and after exiting Debug-Mode ",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1",
        "Requirement Location": "Section 10.15: DSCRATCH0/DSCRATCH1 ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DSCRATCH 0\nDSCRATCH 1",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify that scratch registers can be written and read while in Debug-Mode.\nVerify that debugger does not write to scratch registers unless hartinfo explicitly mentions it.",
        "Pass/Fail Critiera": "Self-checking of DSCRATCH registers expected values while in Debug-Mode.",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.8.3: Debug Scratch Register 0 (dscratch0, at 0x7b2) \nSection 4.8.4: Debug Scratch Register 1 (dscratch1, at 0x7b3) ",
        "Feature": "Debug-Mode registers",
        "Sub-Feature": "DSCRATCH 0\nDSCRATCH 1",
        "Feature Description": "The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:\n|------------------------------------------------------------|\n|Address| R/W  |               Description                           |\n|----------|-------|----------------------------------------|\n| [31:28]  |    R     | Ext. debug support exists             |\n|       [15]  | R/W  | ebreakm                                              |\n|       [13]  | R/W  | ebreaks (*)                                        |\n|       [12]  | R/W  | ebreaku                                               |\n|       [11]  |WARL| stepi                                                     |\n|       [10]  |WARL| stopcount (*)                                    |\n|         [9]  |WARL| stoptime (*)                                      |\n|      [8:6] |    R      | cause                                                    |\n|         [4]  |R/W| mprven (*)                                            |\n|         [3]  |R/W| nmip (*)                                                  |\n|          [2] |R/W| step                                                           |\n|      [1:0]  |   R   | returns current priviledge mode  |\n|------------------------------------------------------------|",
        "Verification Goal": "Verify that scratch registers can be written and read while in Debug-Mode.\nVerify that debugger does not write to scratch registers unless hartinfo explicitly mentions it.",
        "Pass/Fail Critiera": "Self-checking of DSCRATCH registers expected values while in Debug-Mode.",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.4: Single Step ",
        "Feature": "Single step execution",
        "Sub-Feature": "DSCRATCH 0\nDSCRATCH 1",
        "Feature Description": "Debugger single steps a instruction and re-enters Debug-Mode by setting step bit (DCSR[2]) before setting \"resumereq\" in Debug Module if implemented.\nInterrupts can be enaled or disabled during stepping by setting the stepi bit in the DCSR",
        "Verification Goal": "Verify dpc = address of next instruction each time Debug-Mode is re-entered for each step\nVerify stepping can be done without Debug Module",
        "Pass/Fail Critiera": "Self-checking of DPC and PC against three expected values: before stepping; during each step; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.4: Single Step ",
        "Feature": "Single step execution",
        "Sub-Feature": "DSCRATCH 0\nDSCRATCH 1",
        "Feature Description": "Debugger single steps a instruction and re-enters Debug-Mode by setting step bit (DCSR[2]) before setting \"resumereq\" in Debug Module if implemented.\nInterrupts can be enaled or disabled during stepping by setting the stepi bit in the DCSR",
        "Verification Goal": "Verify dpc = address of next instruction each time Debug-Mode is re-entered for each step\nVerify stepping can be done without Debug Module",
        "Pass/Fail Critiera": "Self-checking of DPC and PC against three expected values: before stepping; during each step; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    },
    {
        "Requirement reference": "RISC-V Ext. Debug Support V 0.13.2",
        "Requirement Location": "Section 4.4: Single Step ",
        "Feature": "Single step execution",
        "Sub-Feature": "DSCRATCH 0\nDSCRATCH 1",
        "Feature Description": "Debugger single steps a instruction and re-enters Debug-Mode by setting step bit (DCSR[2]) before setting \"resumereq\" in Debug Module if implemented.\nInterrupts can be enaled or disabled during stepping by setting the stepi bit in the DCSR",
        "Verification Goal": "Verify dpc = address of next instruction each time Debug-Mode is re-entered for each step\nVerify stepping can be done without Debug Module",
        "Pass/Fail Critiera": "Self-checking of DPC and PC against three expected values: before stepping; during each step; and after exiting Debug-Mode",
        "Type": "OpenHW Compliance, \nDirected Self-Checking",
        "Coverage Method": "Functional Coverage",
        "Link to Coverage": "Not yet coded"
    }
]