Requirement reference,Requirement Location,Feature,Sub-Feature,Feature Description,Verification Goal,Pass/Fail Critiera,Type,Coverage Method,Link to Coverage
Privileged ISA Version 20190608-Priv-MSU-Ratified,Section 3.2.1: Environment Call and Breakpoint ,Privileged Debugger Breakpoint,"(Machine-Mode) ebreak
push PC -> MEPC
(debugmode) mret
pop MEPC -> PC","ebreak instruction switches core into Debug-Mode synchronously: 
mepc = address of ebreak instruction.
PC = mepc on return form exception.","add ebreak to arbitrary Machine-Mode code in wide-range of  locations. 
Verify return to User-Mode after execution.","Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode.
Verification that CSR/DCSR and PC/DPC registers are updated as expected","OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,"Section 10.1: Machine Status (MSTATUS)
Section 10.5: Machine Exception PC (MEPC)
",Machine Exception PC register,"(Machine-Mode) ebreak
push PC -> MEPC
(debugmode) mret
pop MEPC -> PC","ebreak instruction switches core  into Debug-Mode synchronously: 
 mepc = address of ebreak instruction on entry. 
PC = mepc on return form exception.

if User-Mode enabled when Machine-Mode ebreak exception occurs, UPIE (MSTATUS[4]) = UIE (USTATUS[0]). PC = mepc on execution of mret (return form exception), UIE(MSTATUS[0]) = MPIE(MSTATUS[4]).","add ebreak to arbitrary Machine-Mode code in wide-range of  locations. 
Verify return to User-Mode after execution.",Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
Unprivileged ISA 20190608-Base-Ratified,"Section 2.8: Environment Call and Breakpoints
Section 25: RV32/64G Instruction Set Listings",Unprivileged Debugger Breakpoint,"(User-Mode) ebrake 
push PC -> UEPC
(debugmode) mret
pop UEPC -> PC","ebreak instruction switches core  into Debug-Mode synchronously: uepc = address of ebreak instruction on entry, UPIE (USTATUS[4]) = UIE (USTATUS[0]). PC = mepc on execution of uret (return form exception, UIE(USTATUS[0]) = UPIE(USTATUS[4]).","add ebreak to arbitrary User-Mode code in wide-range of  locations. 
Verify return to User-Mode after execution.",Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,"Section 10.2: User Status (USTATUS)
Section 10.6: User Exception PC (UEPC)",User Exception PC register,"(User-Mode) ebrake 
push PC -> UEPC
(debugmode) mret
pop UEPC -> PC",,"add ebreak to arbitrary User-Mode code in wide-range of  locations. 
Verify DPC address is that of the ebreak instruction.
Verify return to User-Mode after execution.",Self-checking against three expected results: before entering Debug-Mode; during Debug-Mode; and after exiting Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
Unprivileged ISA 20190608-Base-Ratified,"Section 2.8: Environment Call and Breakpoints
Section 25: RV32/64G Instruction Set Listings",Unprivileged Debugger Breakpoint,"U-Mode ebreak ""semihosting""","to support ""Semihosting"", a special instruction sequence used to enable “Semihosting”  (communicate-with and use I/O of ext. host computer) over system call interface: 
   slli x0, x0, 0x1f    # Entry NOP
   ebreak                    # Break to debugger
   srai x0, x0, 7          # NOP encoding semihosting call #7","add speciual ""semihosting"" ebreak instruction sequence to arbitrary User-Mode code in wide-range of  locations.
Verify ext. host computer I/O transactions.  
Verify DPC address is that of the ebreak instruction.
Verify return to User-Mode after execution.","Self-checking against three expected results: before entering ""semihosting""; during ""semihosting""; and after exiting ""semihosting""","OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RISC-V Ext. Debug Support V 0.13.2,Section 4.3: Wait for Interrupt Instruction ,graceful Debug-Mode from WFI,,"Debug-Mode can be entered via an ebreak exception or a debug_req_i  interrupt. if either is requested while an interrupt is already beings services, Debug-Mode will  be entered after completion of wait-for-interrupt (wfi)",Verify that Debug only enters after completion of wait-for-interrupt (wfi),Self-checking against five expected results: before entering interrupt; at the beginning of interrupt; after the Debug-Mode while still in the interrupt; after exiting the interrupt; in Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
Privileged ISA Version 20190608-Priv-MSU-Ratified,"Section 1.3: Debug Mode 
Section 2.1: CSR Address Mapping Conventions",Debug-Mode only Debug-CSRs and memory address space,,"Debug-Mode CSR and DM_HaltAddress and range exclusively accessible in Debug mode.  
debug_req_i switches core  into Debug-Mode jumping to DM_HaltAddress & storing next instruction addr. in DPC
|------------------|-----------------------------------------------|
|Address (Hex) |                  Use & Accessibility                     |
|------------------|-----------------------------------------------|
| 0x7B0-0x7BF   |Debug-mode-only CSRs                             |
|   *_TBD_*          |DM_HaltAddress                                           |
|------------------|-----------------------------------------------|
Illegal instruction exception shall be raised on non-Debug-Mode access.

dret instruction changes pc to value stored in dpc, privilege-level changed to prv in dcsr, then hart exits Debug-Mode. ",Verify exclusive Debug-Mode memory address space can only be accessed in Debug-Mode.,Self-checking against three expected results: before entering Debug-Mode; after jump to DM_HaltAddress; and after exiting Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,Section 13: Debug Unit ,Debug Request Interrupt,"debug_req_i interrupt jumping to ""DM_HaltAddress""",,"Verify DM_HaltAddress program, including data sections and exception tables must fit in 1Mbyte space starting at address 0; address DM_HALTADDRESS must exist in the memory map; and should have executable code producing predictable result.",,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RISC-V Ext. Debug Support V 0.13.2,Section 4.6: dret Instruction ,Return from Debug-Mode instruction,,,verify that dret outside Debug-Mode causes illegal instruction exception.,,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
Privileged ISA Version 20190608-Priv-MSU-Ratified,Section 2.2: CSR Listing ,Debug-Mode CSR addresses and access restrictions,,"* Table 2.6: Allocated RISC-V CSR addresses.
|--------|------------|--------------------------------------------|
|  Addr | Name       |    Use & Accessibility                              |
|--------|------------|--------------------------------------------|
| 0x7B0 |dcsr           |D-Mode Debug Control & Status reg|
| 0x7B1 |dpc            |D-Mode Debug PC                                    |
| 0x7B2 |dscratch0|D-Mode Debug scratch reg 0                |
| 0x7B3 |dscratch1|D-Mode Debug scratch reg 1                |
|--------|------------|--------------------------------------------|","Verify Debug CSR only accessible in Debug-Mode. 
Illegal instruction exception raised on non-Debug-Mode access.",Self-checking access expected illegal instruction exception by trying to access when not in Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,Section 10.13: Debug Control and Status (DCSR)  ,Debug-Mode registers,DCSR,"The following fields are available in the Debugger-CSR when in debugger mode. fields with (*) are different from Privileged ISA document:
|------------------------------------------------------------|
|Address| R/W  |               Description                           |
|----------|-------|----------------------------------------|
| [31:28]  |    R     | Ext. debug support exists             |
|       [15]  | R/W  | ebreakm                                              |
|       [13]  | R/W  | ebreaks (*)                                        |
|       [12]  | R/W  | ebreaku                                               |
|       [11]  |WARL| stepi                                                     |
|       [10]  |WARL| stopcount (*)                                    |
|         [9]  |WARL| stoptime (*)                                      |
|      [8:6] |    R      | cause                                                    |
|         [4]  |R/W| mprven (*)                                            |
|         [3]  |R/W| nmip (*)                                                  |
|          [2] |R/W| step                                                           |
|      [1:0]  |   R   | returns current priviledge mode  |
|------------------------------------------------------------|",Verify DCSR fields can be updated and that read/write permissions are respected. ,Self-checking of DCSR expected values.,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RISC-V Ext. Debug Support V 0.13.2,"Section 4 .8.1: Debug Control and Status (dcsr, at 0x7b0) ",Debug-Mode registers,DCSR,,,,,,
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,Section 10.14: DPC ,Debug-Mode registers,DPC,,Verify that DPC contains address of next instruction to be executed if Debug Mode would not have been entered.,Self-checking of DPC and PC against three expected values: before entering Debug-Mode; while in Debug-Mode; and after exiting Debug-Mode ,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RISC-V Ext. Debug Support V 0.13.2,"Section 4.8.2: Debug PC (dpc, at 0x7b1) ",Debug-Mode registers,DPC,,,,,,
RI5CY: User Manual Dec. 2019 Revision 4.2 14.5.1,Section 10.15: DSCRATCH0/DSCRATCH1 ,Debug-Mode registers,"DSCRATCH 0
DSCRATCH 1",,"Verify that scratch registers can be written and read while in Debug-Mode.
Verify that debugger does not write to scratch registers unless hartinfo explicitly mentions it.",Self-checking of DSCRATCH registers expected values while in Debug-Mode.,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
RISC-V Ext. Debug Support V 0.13.2,"Section 4.8.3: Debug Scratch Register 0 (dscratch0, at 0x7b2) 
Section 4.8.4: Debug Scratch Register 1 (dscratch1, at 0x7b3) ",Debug-Mode registers,"DSCRATCH 0
DSCRATCH 1",,,,,,
RISC-V Ext. Debug Support V 0.13.2,Section 4.4: Single Step ,Single step execution,,"Debugger single steps a instruction and re-enters Debug-Mode by setting step bit (DCSR[2]) before setting ""resumereq"" in Debug Module if implemented.
Interrupts can be enaled or disabled during stepping by setting the stepi bit in the DCSR","Verify dpc = address of next instruction each time Debug-Mode is re-entered for each step
Verify stepping can be done without Debug Module",Self-checking of DPC and PC against three expected values: before stepping; during each step; and after exiting Debug-Mode,"OpenHW Compliance, 
Directed Self-Checking",Functional Coverage,Not yet coded
,,,,,,,,,
,,,,,,,,,
